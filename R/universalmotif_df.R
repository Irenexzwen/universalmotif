#' Tidy manipulation of motifs.
#'
#' @return
#'    For [to_df()]: a `data.frame` with the exposed slots as columns.
#'
#'    For [update_motifs()]: the updated `data.frame`.
#'
#'    For [to_list()]: a list of motifs.
#'
#' @examples
#' \dontrun{
#' library(universalmotif)
#' library(dplyr)
#'
#' m <- c(create_motif(name = "motif A"), create_motif(name = "motif B"))
#'
#' # Change the names of the motifs using the tidy way:
#' m <- m %>%
#'    to_df() %>%
#'    mutate(name = paste0(name, "-2")) %>%
#'    to_list()
#'
#' # Add random metadata to be stord in the extrainfo slot:
#' m_df <- to_df(m)
#' m_df$MyMetadata <- c("Info_1", "Info_2")
#' m <- to_list(m_df, extrainfo = TRUE)
#' }
#'
#' @author Benjamin Jean-Marie Tremblay, \email{b2tremblay@@uwaterloo.ca}
#' @name tidy-motifs
NULL

#' @export
as.character.universalmotif <- function(x, maxchar = 12, ...) {
  name <- x["name"]
  if (nchar(name) > (maxchar - 6)) name <- paste0(substr(name, 1, maxchar - 8), "..")
  paste0("<mot:", name, ">")
}

#' @export
print.universalmotif_df <- function(x, na.rm = TRUE, ...) {
  # check for validity? if so, move some of the code in update_motifs to a new fun?
  y <- x
  if (na.rm) {
    empty_cols <- vapply(x, function(x) all(is.na(x)), logical(1))
    x <- x[, !empty_cols, drop = FALSE]
  }
  print.data.frame(x)
  if (na.rm && any(empty_cols)) {
    empty_cols <- colnames(y)[empty_cols]
    empty_cols <- paste0(empty_cols, collapse = ", ")
    cat("\n", wmsg("[Hidden empty columns: ", empty_cols, "]"), "\n", sep = "")
  }
  invisible(x)
}

#' @export
#' @param motifs List of motifs.
#' @rdname tidy-motifs
to_df <- function(motifs, extrainfo = FALSE) {
  # TODO: extrainfo
  x <- convert_motifs(motifs)
  if (!is.list(x)) x <- list(x)
  y <- summarise_motifs_with_extras(x)
  if (extrainfo) {
    y <- cbind(y, extrainfo_to_df(x))
  }
  # interesting side effect of using I(x): trying to use the motif column directly
  # in functions such as view_motifs(df$motif) will throw an error.
  # Maybe provide a method for "AsIs" in convert_motifs() which will throw a more
  # informative error message? (Add extra class alongside "AsIs"?)
  y <- cbind(motif = I(x), y)
  # some functions may drop the extra class, but it should only affect pretty printing
  structure(y, class = c("universalmotif_df", "data.frame"))
}

#' @export
#' @param motif_df Motif `data.frame` generated by [to_df()].
#' @param extrainfo Use the `extrainfo` slot in the tidy `data.frame`. The
#'    column names will be taken from the character vectors themselves, and
#'    unnamed elements will be assigned a unique name. To add elements to the
#'    slot, simply create new columns in the `data.frame`. Note that these will
#'    be coerced into characters. If `extrainfo` is not set to `TRUE` in
#'    `to_df()`, then the contents of the slot will be transferred to the
#'    `data.frame`. If `extrainfo` is not set to `TRUE` in `update_motifs()`
#'    or `to_list()`, then the extra columns will be discarded.
#' @rdname tidy-motifs
update_motifs <- function(motif_df, extrainfo = FALSE) {
  # TODO: extrainfo implementation is very messy...
  # TODO: come back and add alphabet change support once switch_alph() is updated
  # TODO: performance
  updated_df <- as.data.frame(motif_df)
  if (!"motif" %in% colnames(updated_df))
    stop("Could not find 'motif' column.")
  m <- updated_df$motif
  class(m) <- NULL
  old_df <- as.data.frame(to_df(m))
  cols_new <- colnames(updated_df)
  cols_new <- cols_new[cols_new != "motif"]
  cols_old <- colnames(old_df)
  cols_old <- cols_old[cols_old != "motif"]
  if (extrainfo) {
    # for now, just always update extrainfo...
    cols_extrainfo <- cols_new[!cols_new %in% cols_old]
    cols_extrainfo <- cols_extrainfo[cols_extrainfo != "bkg"]
    if (length(cols_extrainfo)) {
      extrainfo_new <- updated_df[, cols_extrainfo]
      for (i in seq_along(m)) {
        m[[i]]["extrainfo"] <- clean_up_extrainfo_df(extrainfo_new[i, ])
      }
    }
  } else if (any(!cols_new %in% cols_old)) {
    # maybe remove this warning based on how extrainfo is implemented
    warning(
      "Discarding unknown slot(s) ",
      paste0(paste0("'", cols_new[!cols_new %in% cols_old], "'"), collapse = ", "),
      immediate. = TRUE, call. = FALSE
    )
  }
  if (any(!cols_old %in% cols_new)) {
    # hide this warning when called in to_list()?
    warning(
      "Restoring missing slot(s) ",
      paste0(paste0("'", cols_old[!cols_old %in% cols_new], "'"), collapse = ", "),
      immediate. = TRUE, call. = FALSE
    )
  }
  cols_to_check <- cols_new[cols_new %in% cols_old]
  if ("bkg" %in% cols_to_check) {
    for (i in which(mapply(bkgs_are_different, old_df$bkg, updated_df$bkg, SIMPLIFY = TRUE))) {
      m[[i]]["bkg"] <- updated_df$bkg[[i]]
    }
    cols_to_check <- cols_to_check[cols_to_check != "bkg"]
  }
  for (i in seq_along(cols_to_check)) {
    checking <- cols_to_check[i]
    # need a better way to deal with NAs...
    updated_df[[checking]][is.na(updated_df[[checking]])] <- 0
    old_df[[checking]][is.na(old_df[[checking]])] <- 0
    if (any(updated_df[[checking]] != old_df[[checking]])) {
      if (checking == "type") {
        for (j in which(updated_df[[checking]] != old_df[[checking]])) {
          m[[j]] <- convert_type(m[[j]], updated_df[[checking]][j])
        }
      } else if (checking %in% c("icscore", "consensus", "alphabet")) {
        warning("Discarding changes in unmodifiable slot(s) '", checking, "'",
          immediate. = TRUE, call. = FALSE)
      } else {
        for (j in which(updated_df[[checking]] != old_df[[checking]])) {
          m[[j]][checking] <- updated_df[[checking]][j]
        }
      }
    }
  }
  to_df(m, extrainfo)
}

#' @export
#' @rdname tidy-motifs
to_list <- function(motif_df, extrainfo = FALSE) {
  structure(update_motifs(motif_df, extrainfo)$motif, class = NULL)
}

summarise_motifs_with_extras <- function(x) {
  y <- summarise_motifs(x, na.rm = FALSE)
  y$type <- vapply(x, function(x) x@type, character(1))
  y$bkg <- lapply(x, function(x) x@bkg)
  y
}

bkgs_are_different <- function(x, y) {
  if (length(x) != length(y)) TRUE
  else !all(x == y)
}

extrainfo_to_df <- function(x) {
  y <- lapply(x, vec_to_df_mot)
  cnames <- unique(unlist(lapply(y, colnames)))
  for (i in seq_along(y)) {
    if (!ncol(y[[i]])) {
      y[[i]] <- vec_to_df(structure(rep(NA_character_, length(cnames)), names = cnames))
    } else {
      for (j in which(!cnames %in% colnames(y[[i]]))) {
        y[[i]][[cnames[j]]] <- rep(NA_character_, nrow(y[[i]]))
      }
      y[[i]] <- y[[i]][, cnames]
    }
  }
  do.call(rbind, y)
}

vec_to_df_mot <- function(x) {
  vec_to_df(x@extrainfo)
}

vec_to_df <- function(x) {
  if (!length(x)) data.frame()
  else {
    # TODO: need to mitigate risk of duplicate names here
    if (is.null(names(x))) names(x) <- paste0("extrainfo.", seq_along(x))
    names(x)[names(x) == ""] <- paste0("extrainfo.", seq_len(sum(names(x) == "")))
    x <- list2DF(as.list(x))
    x
  }
}

clean_up_extrainfo_df <- function(x) {
  y <- names(x)
  x <- as.character(x)
  if (all(is.na(x))) character()
  else {
    names(x) <- y
    x[!is.na(x)]
  }
}
