---
title: "Introduction to motif manipulation with the \"universalmotif\" package"
shorttitle: "Intro to \"universalmotif\""
author:
- name: Benjamin Tremblay
  affiliation: University of Waterloo, Waterloo, Canada
  email: b2tremblay@uwaterloo.ca
abstract: >
  Import, manipulate, and export motifs with R.
bibliography: universalmotif.bib
vignette: >
  %\VignetteIndexEntry{Introduciton to motif manipulation with the "universalmotif" package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(collapse=TRUE, comment="#>")
```

# Installation

```{r, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("universalmotif")
```


# Introduction to sequence motifs

Motifs are a more practical representation of consensus elements in biological
sequences, allowing for a more detailed description of the variability at each
site [see @motifhist]. There are a number of ways of representing motifs; four
types are available here. All of these can be stored using the same
`universalmotif` class. Unfortunately, the naming conventions for the various
motif types are not unanimous. In order to provide a simple interface to the
various types, in this package they are referred to as Position Count Matrix
(PCM), Position Probability Matrix (PPM), Position Weight Matrix (PWM), and
Information Content Matrix (ICM). 

These four types will be described here. Furthermore, the actual code used to
go between these types can be see in `?utilities`.

## Position count matrices

Also known as position frequency matrices, these are typically the most basic
representation of a motif. Simply, for each position the total counts of
letters is shown. For example, the following sequences:

 # | Sequence
-- | --------
 1 | AAGAAT
 2 | ATCATA
 3 | AAGTAA
 4 | AACAAA
 5 | ATTAAA
 6 | AAGAAT
: (\#tab:seqs) Starting sequences.

... would be represented as:

Position | 1 | 2 | 3 | 4 | 5 | 6
-------- | - | - | - | - | - | -
       A | 6 | 4 | 0 | 5 | 5 | 4
       C | 0 | 0 | 2 | 0 | 0 | 0
       G | 0 | 0 | 3 | 0 | 0 | 0
       T | 0 | 2 | 1 | 1 | 1 | 2
: (\#tab:pcm) Position count matrix.

_(Note that all positions sum to 6, the initial number of sequences.)_

## Position probability matrices

Also sometimes known as position frequency matrices and position weight
matrices, these represent the probabilities for each letter at each position.
Using the previous motif (table \@ref(tab:pcm)) as an example, the following
formula would be used to calculate the probability of each letter _N_
at each individual position:

\begin{equation}
  Prob_N = \frac{Counts_N}{Counts_{Total}}
  (\#eq:pcm2ppm)
\end{equation}

This leads to the following motif representation:

Position |    1 |    2 |    3 |    4 |    5 |    6
-------- | ---- | ---- | ---- | ---- | ---- | ----
       A | 1.00 | 0.67 | 0.00 | 0.83 | 0.83 | 0.66
       C | 0.00 | 0.00 | 0.33 | 0.00 | 0.00 | 0.00
       G | 0.00 | 0.00 | 0.50 | 0.00 | 0.00 | 0.00
       T | 0.00 | 0.33 | 0.17 | 0.17 | 0.17 | 0.33
: (\#tab:ppm) Position probability matrix.

_(Note that all positions sum to 1.)_

From this type of representation, the probability of any combination of letters
can be calculated. For example, the probability for AAGAAA is about 15%.
However, when starting from a small pool of sequences, many zeroes can appear
in the PPM; meaning that, for example, the probability of AAAAAA is currently
zero. When scanning through large numbers of biological sequences, throwing away
combinations of
letters such as these can be undesirable, as for example  mimatches can be quite
common in transcription factor binding sites; this can be fixed by adding a
'pseudocount'. Usually a small number such as 1, it is introduced into the PCM
to PPM caculation:

\begin{equation}
  Prob_N = \frac{Counts_N + \frac{Pseudocount}{length_N}}{Counts_{Total} + Pseudocount}
  (\#eq:ppmpseudo)
\end{equation}

In this equation, the pseudocount is added to the top and bottom of the
fraction. However for the top fraction, which is specific to each
letter, the pseudocount is divided by the total number of letters (in the case
of DNA, 4). This then generates the following motif:

Position |     1 |     2 |     3 |     4 |     5 |     6
-------- | ----- | ----- | ----- | ----- | ----- | -----
       A | 0.892 | 0.610 | 0.036 | 0.750 | 0.750 | 0.610
       C | 0.036 | 0.035 | 0.320 | 0.035 | 0.035 | 0.035
       G | 0.036 | 0.035 | 0.464 | 0.035 | 0.035 | 0.035
       T | 0.036 | 0.320 | 0.180 | 0.180 | 0.180 | 0.320
: (\#tab:ppmpseudo) Position probability matrix with a pseudocount of 1.

Now, though unlikely, it is no longer considered impossible for the sequence
AAAAAA to exist as part of this motif. Since the total number of sequences in
this case is quite low, the pseudocount can have a large impact on the values
within the matrix; this impact decreases as the number of sequences increases.
Of course, this can also be changed by using different pseudocounts.

## Position weight matrices

The position weight matrix, also known as position-specific weight matrix,
position-specific scoring matrix, and logodds scoring matrix, was first
proposed by @pwm. In this case for
each position, every letter has a 'score'; this can be used to evaluate how
well a sequence matches a motif. Though there can be multiple ways of calculating
these scores, the most common method is to calculate the log of each
probability, correcting for background frequencies. This results in the
following calculation:

\begin{equation}
  Score_N = \log_{2}\left(\frac{Prob_N}{ProbBkg_N}\right)
  (\#eq:ppm2pwm)
\end{equation}

Using this equation, the log of fractions where the probability of a
certain letter in
a sequence is higher than that of the background probability of that letter
result in positive scores, and vice versa for negative scores. Using the table
\@ref(tab:ppm) motif and assuming a uniform background frequency (i.e. the
probability of each of the four letters is 0.25), this results in the following PWM:

Position |    1 |     2 |      3 |      4 |      5 |     6
-------- | ---- | ----- | ------ | ------ | ------ | -----
       A |    2 | 1.425 |   -Inf |  1.737 |  1.737 | 1.415
       C | -Inf |  -Inf |  0.415 |   -Inf |   -Inf |  -Inf
       G | -Inf |  -Inf |  1.000 |   -Inf |   -Inf |  -Inf
       T | -Inf | 0.415 | -0.585 | -0.585 | -0.595 | 0.415
: (\#tab:pwm) Position weight matrix.

_(Note that the position totals no longer have equal sums.)_

In order to score a sequence, add up the score for the letters at the specific
positions; for example AAGAAA has a score of 9.31. However, similar to with
PPMs, if starting from a small pool of sequences the sequence AAAAAA could
never be recovered using this motif model, with a score of -Inf. This can
be avoided simply by starting from a pseudocount-adjusted PPM. Using the table
\@ref(tab:ppmpseudo) motif, this becomes:

Position |      1 |      2 |      3 |      4 |      5 |      6
-------- | ------ | ------ | ------ | ------ | ------ | ------
       A |  1.840 |  1.280 | -2.807 |  1.585 |  1.585 |  1.280
       C | -2.807 | -2.807 |  0.363 | -2.807 | -2.807 | -2.807
       G | -2.807 | -2.807 |  0.893 | -2.807 | -2.807 | -2.807
       T | -2.807 |  0.363 | -0.485 | -0.485 | -0.485 |  0.363
: (\#tab:pwmpseudo) Position weight matrix with a pseudocount of 1.

Now, the score for AAGAA is 8.46, and the score for AAAAAA is 4.76. Though the
score for the latter is low, it is no longer -Inf as a result of one mismatch.

When searching for instances of this motif using this scoring system, one more
consideration is needed: a minimum score. For example, both sequences AAGAAA
and ATTTTT have positive scores; but one is much higher than the other. Should
ATTTTT then be discarded? In order to answer this a threshold is set; typically
this is a certain percent of the highest possible score. For example, in the table
\@ref(tab:pwmpseudo) motif, the highest possible score is 8.46; using
a threshold of 25%, the minimum score then becomes 2.115. This means that
ATTTTT, with a score of 1.112, would indeed be discarded.

Other methods for determining the minimum score include starting from
P-values. The package `r CRANpkg("TFMPvalue")` for example can calculate minimum
scores from P-values, using the algorithm described by @pval.

## Information content matrices

Finally, the information content matrix [@correction; @icm]. This type aims to
include another
consideration: are some positions more important than others? To explore this,
let us consider the table \@ref(tab:ppm) motif. This matrix can be represented
as a sequence logo using the `r Biocpkg("seqLogo")` package:

```{r,fig.cap="Sequence logo of a PPM",echo=FALSE}
library(universalmotif)
library(seqLogo)
motif <- create_motif(c("AAGAAT", "ATCATA", "AAGTAA", "AACAAA", "ATTAAA",
                        "AAGAAT"), type = "PPM", pseudocount = 0)
seqLogo::seqLogo(motif["motif"], ic.scale = FALSE)
```

In this case, the height of the letters represent their probabilities at each
position. However, when represented as an ICM, the sequence logo then
resembles:


```{r,fig.cap="Sequence logo of an ICM",echo=FALSE}
library(universalmotif)
library(seqLogo)
motif <- create_motif(c("AAGAAT", "ATCATA", "AAGTAA", "AACAAA", "ATTAAA",
                        "AAGAAT"), type = "PPM", pseudocount = 0)
seqLogo::seqLogo(motif["motif"], ic.scale = TRUE)
```

Now, the total height of each position is scaled using the total
_information_ at that position. Simply put, the total information of each
position is an indication of the level of conservation; in the example motif,
the first position is highly conserved, always being the letter A, whereas the
third position is less so conserved, as the probabilities for any one letter
are quite lower.

For every position, the letter heights are calculated as the total possible
information content (IC) or maximum uncertainty, then subtracting that
positions' actual uncertainty
[@correction; @icm]. This calculation is based on Shannon's entropy
[@shannon], with the final values representing 'bits' [@bits].
The total IC is based on alphabet length,
using the following equation:

\begin{equation}
  IC_{total} = \log_{2}(length_N)
  (\#eq:totalic)
\end{equation}

For DNA motifs which have an alphabet length of 4, the total IC is 2. To
calculate the positions' actual uncertainty, the following equation is used:

\begin{equation}
  Uncertainty = - \sum_{N=A}^{T} Prob_N \times{} \log_{2}(Prob_N)
  (\#eq:posuncer)
\end{equation}

Where the position uncertainty is the sum of the uncertainty of all alphabet
letters (A, C, G, and T). To calculate the final information content:

\begin{equation}
  IC_{position} = IC_{total} - Uncertainty
  (\#eq:ic)
\end{equation}

In the original implementation described by @correction, an additional error
correction factor is included to account for sample size. This correction is
rarely used however, but can be incorporated as such:

\begin{equation}
  IC_{position} = IC_{total} - [ Uncertainty + E_{corr} ]
  (\#eq:iccorr)
\end{equation}

The details for calculating this factor will not be covered here; refer to
@correction. The `r Biocpkg("TFBSTools")` package offers the ability to
incorporate this error correction.

Finally, to get the height of each letter at each position, the final IC is
multiplied by the letter and position probabilities:

\begin{equation}
  IC_N = Prob_N \times{} IC_{position}
  (\#eq:finalic)
\end{equation}

Using the above equations, the table \@ref(tab:ppm) motif then becomes:

Position |      1 |      2 |      3 |      4 |      5 |      6
-------- | ------ | ------ | ------ | ------ | ------ | ------
       A |  2.000 |  0.721 |  0.000 |  1.125 |  1.125 |  0.721
       C |  0.000 |  0.000 |  0.180 |  0.000 |  0.000 |  0.000
       G |  0.000 |  0.000 |  0.270 |  0.000 |  0.000 |  0.000
       T |  0.000 |  0.361 |  0.090 |  0.225 |  0.225 |  0.361
: (\#tab:icm) Information content matrix.

_(Note that none of the positions have a sum larger than 2.)_

An alternative to representing information content as Shannon's entropy is
relative entropy, or Kullback-Leibler divergence [@kl]. While IC as Shannon's
entropy has the advantage of having a consistent maximum IC for every position,
it does not take into account non-uniform background frequencies. Relative
entropy on the other hand will take this into account, but all positions no
longer share the same maximum IC. To calculate relative entropy:

\begin{equation}
  IC_N = Prob_N \times{} \log_{2}\left(\frac{Prob_N}{ProbBkg_N}\right)
  (\#eq:kldiv)
\end{equation}

Using this equation can lead to IC less than zero; these values are not
allowed, so they are simply replaced with zero.
With this equation and assuming uniform background frequencies, the table
\@ref(tab:ppm) motif becomes:

Position |      1 |      2 |      3 |      4 |      5 |      6
-------- | ------ | ------ | ------ | ------ | ------ | ------
       A |  1.640 |  0.777 |  0.000 |  1.190 |  1.190 |  0.777
       C |  0.000 |  0.000 |  0.177 |  0.000 |  0.000 |  0.000
       G |  0.000 |  0.000 |  0.415 |  0.000 |  0.000 |  0.000
       T |  0.000 |  0.177 |  0.090 |  0.000 |  0.000 |  0.117
: (\#tab:icmkl) Information content matrix as relative divergence.

This motif would look significantly different with non-uniform background
frequences. For example, starting from the following background frequencies: 
`c(A = 0.4, C = 0.1, G = 0.1, T= 0.4)`, the motif resembles:

Position |      1 |      2 |      3 |      4 |      5 |      6
-------- | ------ | ------ | ------ | ------ | ------ | ------
       A |  1.030 |  0.366 |  0.000 |  0.680 |  0.680 |  0.366
       C |  0.000 |  0.000 |  0.541 |  0.000 |  0.000 |  0.000
       G |  0.000 |  0.000 |  1.028 |  0.000 |  0.000 |  0.000
       T |  0.000 |  0.000 |  0.090 |  0.000 |  0.000 |  0.000
: (\#tab:icmkl2) Information content matrix as relative divergence with
a non-uniform background.

# The universalmotif class and conversion utilities

## The universalmotif class

The `r Biocpkg("universalmotif")` package stores motifs using the
`universalmotif` class. The most basic `universalmotif` object exposes the 'name',
'alphabet', 'type', 'type', 'strand', 'icscore', 'consensus', and 'motif'
slots; furthermore, the 'pseudocount' and 'bkg' slots are also stored but not
shown. `universalmotif` class motifs can be PCM, PPM, PWM, or ICM type.

```{r}
library(universalmotif)
data(examplemotif)
examplemotif
```

Exposing the motif class with `str` shows the other available slots:

```{r showslots,echo=FALSE}
library(universalmotif)
data(examplemotif)
str(examplemotif)
```

The other slots will be shown once filled:

```{r}
library(universalmotif)
data(examplemotif)

## The various slots can be accessed individually using `[`
examplemotif["consensus"]

## To change a slot, use `[<-`
examplemotif["family"] <- "My motif family"
examplemotif
```

Though the slots can easily be changed manually with `[<-`, a number of
safeguards have been put in place for some of the slots which will prevent
incorrect values from being introduced.

```{r,error=TRUE}
library(universalmotif)
data(examplemotif)

## The consensus slot is dependent on the motif matrix
examplemotif["consensus"]

## Changing this would mean it no longer matches the motif
examplemotif["consensus"] <- "GGGAGAG"

## Another example:
examplemotif["strand"] <- "x"

## Of course, this can be circumvented by simply using `@`; do this at your
## own risk. Trying to use a motif with an incorrectly filled slot will likely
## cause other universalmotif functions to fail.
examplemotif@strand <- "x"
examplemotif
```

Below the exposed metadata slots, the actual 'motif' matrix is shown. Each
position is its' own column; row names showing the alphabet letters, and 
the column names showing the consensus letter at each position.

## Converting to and from another package's class

The `r Biocpkg("universalmotif")` package aims to unify most of the
motif-related Bioconductor packages by providing the `convert_motif` function.
This allows for easy transition between supported packages (see
`?convert_motif` for a complete list of supported packages).

```{r}
library(universalmotif)
data(examplemotif)
suppressPackageStartupMessages(library(TFBSTools))
data(MA0003.2)
suppressPackageStartupMessages(library(MotifDb))

## convert from a universalmotif to another
convert_motifs(examplemotif, "TFBSTools-PWMatrix")

## convert to universalmotif
convert_motifs(MA0003.2)

## convert between two packages
convert_motifs(MotifDb[1], "TFBSTools-ICMatrix")
```

The `convert_motifs` function is embedded in most of the
`r Biocpkg("universalmotif")` functions, meaning that compatible motif classes
from other packages can be used without needed to convert them first.

# Importing and exporting motifs

## Importing

The `r Biocpkg("universalmotif")` package offers a number of `read_` functions
to allow for easy import of various motif formats. These include:

* `read_cisbp`: CIS-BP [@cisbp]
* `read_homer`: HOMER [@homer]
* `read_jaspar`: JASPAR [@jaspar]
* `read_meme`: MEME [@meme]
* `read_transfac`: TRANSFAC [@transfac]
* `read_uniprobe`: UniPROBE [@uniprobe]

These functions should work natively with these formats, but if you are
generating your own motifs in one of these formats than it must adhere quite
strictly to the format. An example of each of these is included in this package;
see `system.file("extdata", package="universalmotif")`.

Additionally, the generic `read_matrix` function can read simply-formatted
motif files; each motif can have a header and a motif matrix.

## Exporting

Compatible motif classes can be written to disk using:

* `write_homer`
* `write_jaspar`
* `write_matrix`
* `write_meme`
* `write_transfac`

The `write_matrix` function, similar to its' `read_matrix` counterpart, can
write motifs as simple matrices with an optional header.

# Modifying motifs and related functions

## Converting motif type

Any `universalmotif` object can transition between PCM, PPM, PWM, and ICM types
seamlessly using the `convert_type` function. The only exception to this is if
the ICM calculation is performed with sample correction, or as relative
entropy. If this occurs, then back conversion to another type will be
inaccurate. 

```{r}
library(universalmotif)
data(examplemotif)

## This motif is currently a PPM:
examplemotif["type"]

## When converting to PCM, the 'nsites' slot is needed to tell it how
## many sequences it originated from. If empty, 100 is used.
convert_type(examplemotif, "PCM")

## For converting to PWM, the 'pseudocount' slot is used to determine if any
## correction should be applied:
examplemotif["pseudocount"]
convert_type(examplemotif, "PWM")

## You can either change the 'pseudocount' slot manually beforehand, or pass
## one to 'convert_type'
convert_type(examplemotif, "PWM", pseudocount = 1)

## There are a couple of additional options for ICM conversion:
## 'nsize_correction' and 'relative_entropy'. The former uses the
## TFBSTools:::schneider_correction function for sample size correction.
## The latter uses the 'bkg' slot to calculate information content.
examplemotif["nsites"] = 10
convert_type(examplemotif, "ICM", nsize_correction = FALSE)
convert_type(examplemotif, "ICM", nsize_correction = TRUE)
examplemotif["bkg"] = c(0.4, 0.1, 0.1, 0.4)
convert_type(examplemotif, "ICM", relative_entropy = TRUE)
```

## Comparing and merging motifs

There a few functions available in other Bioconductor packages which allow for
motif comparison. These include `PWMSimlarity` (`r Biocpkg("TFBSTools")`),
`motifDistances` (`r Biocpkg("MotIV")`), and `motifSimilarity`
(`r Biocpkg("PWMEnrich")`). Unfortunately these functions are not designed for
comparing large numbers of motifs, and can result in long run times.
The `r Biocpkg("universalmotif")` package
aims to fix this by providing the `compare_motifs` function. Using the
`r Biocpkg("TFBSTools")` implementation as a source, the function has been
rewritten in C++ and allows for comparing thousands of motifs in seconds.

```{r}
library(universalmotif)
library(MotifDb)

## No need to convert class, most universalmotif functions will do it
## automatically
motifs.dist <- compare_motifs(MotifDb[1:5])
as.dist(motifs.dist)

## If comparing thousands of motifs, multicore usage is made available via
## the 'BiocParallel' package

library(BiocParallel)
parallel.opt <- bpparam()
## To add a progress bar:
# parallel.opt$progressBar <- TRUE
motifs.dist <- compare_motifs(MotifDb[1:5], BPPARAM = parallel.opt)
```

Additionally, `r Biocpkg("universalmotif")` provides the `merge_motifs`
function. This first finds the best alignment of input motifs before merging.

```{r}
library(universalmotif)
library(MotifDb)

motifs <- convert_motifs(MotifDb[1:5])

## Two merging methods are offered: via the 'msa' package, and via the 
## 'motifStack' package.
# merge_motifs(motifs, method = "msa")
# merge_motifs(motifs, method = "motifStack")
```

## Multi-letter information

Though PCM/PPM/PWM/ICM type motifs are still widely used today, a few 'next
generation' motif formats have been proposed. These wish to add another layer
of information to motifs: nucleotide interdependence. To illustrate this,
consider the following sequences:

 # | Sequence
-- | --------
 1 | CAAAACC
 2 | CAAAACC
 3 | CAAAACC
 4 | CTTTTCC
 5 | CTTTTCC
 6 | CTTTTCC
: (\#tab:seqs2) Example sequences.

This becomes the following PPM:

Position |   1 |   2 |   3 |   4 |   5 |   6 |   7
-------- | --- | --- | --- | --- | --- | --- | ---
       A | 0.0 | 0.5 | 0.5 | 0.5 | 0.5 | 0.0 | 0.0
       C | 1.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0 | 1.0
       G | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0
       T | 0.0 | 0.5 | 0.5 | 0.5 | 0.5 | 0.0 | 0.0
: (\#tab:ppm2) Position probability matrix.

Based on the PPM representation, all three of CAAAACC, CTTTTCC, and CTATACC are
equally likely. Though looking at the starting sequences, should CTATACC really
be considered so? For transcription factor binding sites, generally the
answer is no. By incorporating this type of information into the motif,
this can allow for increased accuracy in motif searching. A few implementations
of this include: TFFM by @tffm, BaMM by @bamm, and KSM by @ksm.

The `r Biocpkg("universalmotif")` package implements its' own, much simplified,
version of this concept. Plainly, the standard PPM has been extended to include
k-letter frequencies, with k being any number higher than 1. For example, the
2-letter version of the table \@ref(tab:ppm2) motif would be:

Position |   1 |   2 |   3 |   4 |   5 |   6 
-------- | --- | --- | --- | --- | --- | --- 
      AA | 0.0 | 0.5 | 0.5 | 0.5 | 0.0 | 0.0
      AC | 0.0 | 0.0 | 0.0 | 0.0 | 0.5 | 0.0
      AG | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0
      AT | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0
      CA | 0.5 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0
      CC | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0
      CG | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0
      CT | 0.5 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0
      GA | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0
      GC | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0
      GG | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0
      GT | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0
      TA | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0
      TC | 0.0 | 0.0 | 0.0 | 0.0 | 0.5 | 0.0
      TG | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0
      TT | 0.0 | 0.5 | 0.5 | 0.5 | 0.0 | 0.0
: (\#tab:multi) 2-letter probability matrix.

This format shows the probability of each letter combined with the probability
of the letter in the next position. The seventh column has been dropped, since
it is not needed; the information in the sixth column is sufficient, and there
is no eighth position to draw 2-letter probabilities from.
Now, the probability of getting CTATACC is no longer equal to CTTTTCC and
CAAAACC. This information is kept in the `multifreq` slot of `universalmotif`
class motifs. To add this information, use the `add_multifreq` function.

```{r}
library(universalmotif)
library(Biostrings)

motif <- create_motif("CWWWWCC", nsites = 6)  ## -> see next section
sequences <- DNAStringSet(rep(c("CAAAACC", "CTTTTCC"), 3))
motif.k2 <- add_multifreq(motif, sequences, add.k = 2)
motif.k2
```

# Motif creation

Though `universalmotif` class motifs can be created using the `new`
constructor, the `r Biocpkg("universalmotif")` package provides the
`create_motif` function which aims to provide a simpler interface to motif
creation. The `universalmotif` class was designed to work natively with DNA,
RNA, and amino acid motifs. Despite this, it can handle any custom alphabet
just as easily.

The `create_motif` function will be introduced briefly here; see `?create_motif`
for details.

## From a PCM/PPM/PWM/ICM matrix

Should you wish to make use of the `r Biocpkg("universalmotif")` functions
starting from a unsupported motif class, you can instead create
`universalmotif` class motifs using the `create_motif` function.

```{r}
motif.matrix <- matrix(c(0.7, 0.1, 0.1, 0.1,
                         0.7, 0.1, 0.1, 0.1,
                         0.1, 0.7, 0.1, 0.1,
                         0.1, 0.7, 0.1, 0.1,
                         0.1, 0.1, 0.7, 0.1,
                         0.1, 0.1, 0.7, 0.1,
                         0.1, 0.1, 0.1, 0.7,
                         0.1, 0.1, 0.1, 0.7), nrow = 4)
motif <- create_motif(motif.matrix, alphabet = "RNA", name = "My motif",
                      pseudocount = 1, nsites = 20, strand = "+")
## The 'type', 'icscore' and 'consensus' slots will be filled for you
motif
```

## From sequences or character strings

If all you have is a particular consensus sequence in mind, you can easily
create a full motif using `create_motif`. This can be convenient if you'd like
to create a motif to use with an external program such as MEME or HOMER.

```{r}
motif <- create_motif("CCNSNGG", nsites = 50, pseudocount = 1)
## write_meme(motif, "meme_motif.txt")

motif
```

## Generating random motifs

If you wish, it's easy to generate random motifs:

```{r}
create_motif()

## You can change the probabilities:
create_motif(bkg = c(0.2, 0.4, 0.2, 0.2))

## With a custom alphabet:
create_motif(alphabet = "QWERTY")
```

# Sequence-related functions

## Sequence shuffling and creation

The `r Biocpkg("Biostrings")` package offers an excellent suite of functions for
dealing with biological sequences. The `r Biocpkg("universalmotif")` package
hopes to help extend these by providing the `create_sequences` and
`shuffle_sequences` functions.

```{r}
library(universalmotif)
## library(Biostrings)
## Create some DNA sequences for use with an external program:
sequences <- create_sequences(seqnum = 500, monofreqs = c(0.3, 0.2, 0.2, 0.3))
## writeXStringSet(sequences, "bkg.fasta")

## Shuffle sequences:
## sequences <- readDNAStringSet("sequences.fasta")
sequences <- shuffle_sequences(sequences)

## Maintain dinucleotide frequencies:
sequences <- shuffle_sequences(sequences, k = 2)

## Create sequences from any starting alphabet:
sequences <- create_sequences(alphabet = "QWERTY")
sequences <- shuffle_sequences(sequences, k = 6)
```

## Searching for motifs in sequences

There are many fantastic motif scanning and enrichment programs available, such
as [HOMER](http://homer.ucsd.edu/homer/index.html) and the
[MEME suite](http://meme-suite.org/) to name a couple. The
`r Biocpkg("universalmotif")` package does not aim to supplant these, but
rather provide convenience functions for quickly scanning a few sequences
without needing to leave the R environment. Furthermore, these functions
allow for taking advantage of the k-letter motif format described earlier.

Two functions are provided: `scan_sequences` and `enrich_motifs`. Given a motif
of length n, `scan_sequences` considers every n-length subset in a sequence and
scores it using the PWM format. If it surpasses the minimum threshold, it is
reported. This is case regardless of whether one is scanning with a regular
motif, or using the k-letter motif format (the k-letter PPM is converted to
a k-letter PWM). The second function, `enrich_motifs`,
simply scans a set of target sequences, then a set of background sequences, and
checks for significant enrichment.

```{r}
library(universalmotif)
library(Biostrings)

sequences <- create_sequences()

## Let us revisit our 2-letter motif example:
motif.k2 <- create_motif("CWWWWCC", nsites = 6)
sequences.k2 <- DNAStringSet(rep(c("CAAAACC", "CTTTTCC"), 3))
motif.k2 <- add_multifreq(motif.k2, sequences.k2, add.k = 2)

## Regular scanning:
head(scan_sequences(motif.k2, sequences, RC = TRUE, verbose = 0))

## Using 2-letter information to scan:
head(scan_sequences(motif.k2, sequences, use.freq = 2, RC = TRUE, verbose = 0))
```

# Motif visualization

## Motif logos

There are several packages which offer motif visualization capabilities,
such as `r Biocpkg("seqLogo")`, `r Biocpkg("Logolas")`,
`r Biocpkg("motifStack")`, and `r CRANpkg("ggseqlogo")`. Here I will briefly
show how to use these to visualize `universalmotif` class motifs.

```{r}
library(universalmotif)
data(examplemotif)

## For all the examples, simply passing the functions a PPM is sufficient
motif <- convert_type(examplemotif, "PPM")
## Only need the matrix itself
motif <- motif["motif"]

## seqLogo:
seqLogo::seqLogo(motif)

## motifStack: 
motifStack::plotMotifLogo(motif)

## Logolas:
if (requireNamespace("Logolas", quietly = TRUE)) {
  colnames(motif) <- seq_len(ncol(motif))
  Logolas::logomaker(motif, type = "Logo")
}

## ggseqlogo:
if (requireNamespace("ggseqlogo", quietly = TRUE)) {
  ggseqlogo::ggseqlogo(motif)
}
```

The `r Biocpkg("Logolas")` and `r CRANpkg("ggseqlogo")` offer many additional
options for logo customization, including custom alphabets as well as manually
determining the heights of each letter, via the
`r Rpackage("grid")` and `r CRANpkg("ggplot2")` packages respectively.

## Motif trees with ggtree and motifStack

The `r Biocpkg("motifStack")` offers a number of excellent functions for
comparing motifs. Any of them can be used after using `convert_motifs`.
Additionally, this package introduces the `motif_tree` function for generating
basic tree-like diagrams for comparing motifs.

```{r}
library(universalmotif)
library(MotifDb)

## A simple motifStack example:
motifs <- convert_motifs(MotifDb[1:10], "motifStack-pfm")
motifStack::motifStack(motifs, layout = "phylog")

## motif_tree is much simpler, but also much faster and allows for
## bigger trees; done via the ggtree package
motif_tree(MotifDb[301:400], layout = "daylight", linecol = "family")
```

# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References {.unnumbered}
