% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/motif_pvalue.R
\name{motif_pvalue}
\alias{motif_pvalue}
\title{Motif P-value and scoring utility}
\usage{
motif_pvalue(motifs, score, pvalue, bkg.probs, use.freq = 1, k = 8,
  progress = FALSE, BP = FALSE, nthreads = 1)
}
\arguments{
\item{motifs}{See \code{\link[=convert_motifs]{convert_motifs()}} for acceptable motif formats.}

\item{score}{\code{numeric} Get a p-value for a motif from a logodds score.}

\item{pvalue}{\code{numeric} Get a logodds score for a motif from a
p-value.}

\item{bkg.probs}{\code{numeric}, \code{list} If supplying individual background
probabilities for each motif, a list. If missing, retrieves the
background from the motif \code{bkg} slot. Note that this only influences
calculating p-values from an input score; calculating a score from an
input p-value currently assumes a uniform background.}

\item{use.freq}{\code{numeric(1)} By default uses the regular motif matrix;
otherwise uses the corresponding \code{multifreq} matrix. Max is 3.}

\item{k}{\code{numeric(1)} For speed, scores/p-values can be approximated after
subsetting the motif every \code{k} columns. If \code{k} is a value
equal or higher to the size of input motif(s), then the calculations
are (nearly) exact. The default, 8, is recommended to those looking for
a good tradeoff between speed and accuracy for jobs requiring repeated
calculations.}

\item{progress}{\code{logical(1)} Deprecated. Does nothing.}

\item{BP}{\code{logical(1)} Allows the use of \pkg{BiocParallel} within
\code{\link[=motif_pvalue]{motif_pvalue()}}. See \code{\link[BiocParallel:register]{BiocParallel::register()}} to change the default
backend. Setting \code{BP = TRUE} is only recommended for exceptionally large
jobs. Note that this is only used for calculating scores from P-values
(in other words, when the \code{pvalue} argument is provided).}

\item{nthreads}{\code{numeric(1)} Run \code{\link[=motif_pvalues]{motif_pvalues()}} in parallel with \code{nthreads}
threads. \code{nthreads = 0} uses all available threads. Note that this is only
used for calculating P-values from scores (in other words, when the \code{score}
argument is provided).}
}
\value{
\code{numeric} A vector of scores/p-values.
}
\description{
For calculating p-values/logodds scores for any number of motifs.
}
\details{
Calculating p-values for motifs can be very computationally intensive. This
is due to how p-values must be calculated: for a given score, all possible
sequences which score equal or higher must be found, and the probability for
each of these sequences (based on background probabilities) summed. For a DNA
motif of length 10, the number of possible unique sequences is 4^10 = 1,048,576.
Finding all possible sequences higher than a given score can be done
very efficiently and quickly with a branch-and-bound algorithm, but as the
motif length increases this calculation becomes impractical. To get
around this, the p-value calculation can be approximated.

In order to calculate p-values for longer motifs, this function uses the
approximation proposed by \insertCite{pvalues;textual}{universalmotif}, where
the motif is subset, p-values calculated for the subsets, and finally
combined for a total p-value. The smaller the size of the subsets, the
faster the calculation; but also, the bigger the approximation. This can be
controlled by setting \code{k}. In fact, for smaller motifs (< 13 positions)
calculating exact p-values can be done individually in reasonable time by
setting \code{k = 12}.

To calculate a score based on a given p-value, the means and variances of
each motif subsets are combined to estimate the distribution of all
possible scores using \code{\link[stats:Normal]{stats::qnorm()}}:

\code{qnorm(pvalue, mean = sum(subset.means), sd = sqrt(sum(subset.vars)))}

For calculating exact scores, \code{\link[stats:ecdf]{stats::ecdf()}} and \code{\link[stats:quantile]{stats::quantile()}} are
used:

\code{quantile(ecdf(scores), probs = pvalue)}

It is important to keep in mind that both approximate and exact score
calculations assume uniform backgrounds, so do not use this function for
motifs with extremely imbalanced backgrounds. To get all possible scores for
each subset, \code{\link[=expand.grid]{expand.grid()}} is used instead of the branch-and-bound
algorithm used for calculating p-values. Keep this in mind for determining
the best \code{k} value for motifs with alphabets longer than those of DNA/RNA
motifs.
}
\examples{
data(examplemotif)

## p-value/score calculations are performed using the PWM version of the
## motif; these calculations do not work if any -Inf values are present
examplemotif["pseudocount"] <- 1
# or
examplemotif <- normalize(examplemotif)

## get a minimum score based on a p-value
motif_pvalue(examplemotif, pvalue = 0.001)

## get the probability of a particular sequence hit
motif_pvalue(examplemotif, score = 0)

## the calculations can be performed for multiple motifs
motif_pvalue(list(examplemotif, examplemotif), pvalue = c(0.001, 0.0001))

## Compare score thresholds and P-value:
scores <- motif_score(examplemotif, c(0.6, 0.7, 0.8, 0.9))
motif_pvalue(examplemotif, scores)

## Calculate the probability of getting a certain match or better:
TATATAT <- score_match(examplemotif, "TATATAT")
TATATAG <- score_match(examplemotif, "TATATAG")
motif_pvalue(examplemotif, TATATAT)
motif_pvalue(examplemotif, TATATAG)

## Get all possible matches by P-value:
get_matches(examplemotif, motif_pvalue(examplemotif, pvalue = 0.0001))

}
\references{
\insertRef{pvalues}{universalmotif}
}
\seealso{
\code{\link[=motif_score]{motif_score()}}
}
\author{
Benjamin Jean-Marie Tremblay, \email{b2tremblay@uwaterloo.ca}
}
