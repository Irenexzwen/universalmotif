% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/enrich_motifs.R
\name{enrich_motifs}
\alias{enrich_motifs}
\title{Enrich for input motifs in a set of sequences.}
\usage{
enrich_motifs(motifs, sequences, bkg.sequences, search.mode = "hits",
  max.p = 1e-05, max.q = 1e-05, max.e = 0.001, qval.method = "fdr",
  positional.test = "t.test", threshold = 0.001,
  threshold.type = "pvalue", verbose = 0, RC = FALSE, use.freq = 1,
  shuffle.k = 2, shuffle.method = "euler",
  return.scan.results = FALSE, progress = FALSE, BP = FALSE,
  nthreads = 1, rng.seed = sample.int(1e+09, 1), motif_pvalue.k = 8)
}
\arguments{
\item{motifs}{See \code{\link[=convert_motifs]{convert_motifs()}} for acceptable motif formats.}

\item{sequences}{\code{\link{XStringSet}} Sequences to scan. Alphabet
should match motif.}

\item{bkg.sequences}{\code{\link{XStringSet}} Optional; if missing,
\code{\link[=shuffle_sequences]{shuffle_sequences()}} is used to create background sequences from
the input sequences.}

\item{search.mode}{\code{character(1)} One of \code{c('hits', 'positional', 'both')}.
See details.}

\item{max.p}{\code{numeric(1)} P-value threshold.}

\item{max.q}{\code{numeric(1)} Adjusted P-value threshold. This is only useful
if multiple motifs are being enriched for.}

\item{max.e}{\code{numeric(1)}. The E-value is calculated by multiplying the adjusted
P-value with the number of input motifs times two
\insertCite{meme2}{universalmotif}.}

\item{qval.method}{\code{character(1)} See \code{\link[stats:p.adjust]{stats::p.adjust()}}.}

\item{positional.test}{\code{character(1)} One of \code{c('t.test', 'wilcox.test', 'chisq.test', 'shapiro.test')}. If using the Shapiro test for
normality, then only the input sequences are tested for positionality;
the background sequences are ignored. See \code{\link[stats:t.test]{stats::t.test()}},
\code{\link[stats:wilcox.test]{stats::wilcox.test()}}, \code{\link[stats:chisq.test]{stats::chisq.test()}}, \code{\link[stats:shapiro.test]{stats::shapiro.test()}}.}

\item{threshold}{\code{numeric(1)} Between 0 and 1. See details.}

\item{threshold.type}{\code{character(1)} One of \code{c('logodds', 'logodds.abs', 'pvalue')}. See details.}

\item{verbose}{\code{numeric(1)} 0 for no output, 4 for max verbosity.}

\item{RC}{\code{logical(1)} If \code{TRUE}, check reverse complement of input
sequences.}

\item{use.freq}{\code{numeric(1)} The default, 1, uses the motif matrix (from
the \code{motif['motif']} slot) to search for sequences. If a higher
number is used, then the matching k-let matrix from the
\code{motif['multifreq']} slot is used. See \code{\link[=add_multifreq]{add_multifreq()}}.}

\item{shuffle.k}{\code{numeric(1)} The k-let size to use when shuffling input
sequences. Only used if no background sequences are input. See
\code{\link[=shuffle_sequences]{shuffle_sequences()}}.}

\item{shuffle.method}{\code{character(1)} One of \code{c('euler', 'markov', 'linear')}.
See \code{\link[=shuffle_sequences]{shuffle_sequences()}}.}

\item{return.scan.results}{\code{logical(1)} Return output from
\code{\link[=scan_sequences]{scan_sequences()}}. For large jobs, leaving this as
\code{FALSE} can save a small amount time by preventing construction of the complete
results \code{data.frame} from \code{\link[=scan_sequences]{scan_sequences()}}.}

\item{progress}{\code{logical(1)} Deprecated. Does nothing.}

\item{BP}{\code{logical(1)} Deprecated. See \code{nthreads}.}

\item{nthreads}{\code{numeric(1)} Run \code{\link[=scan_sequences]{scan_sequences()}} in parallel with \code{nthreads}
threads. \code{nthreads = 0} uses all available threads.
Note that no speed up will occur for jobs with only a single motif and
sequence.}

\item{rng.seed}{\code{numeric(1)} Set random number generator seed. Since shuffling
can occur simultaneously in multiple threads using C++, it cannot communicate
with the regular \code{R} random number generator state and thus requires an
independent seed. Each individual sequence in an \code{\link{XStringSet}} object will be
given the following seed: \code{rng.seed * index}. See \code{\link[=shuffle_sequences]{shuffle_sequences()}}.}

\item{motif_pvalue.k}{\code{numeric(1)} Control \code{\link[=motif_pvalue]{motif_pvalue()}} approximation.
See \code{\link[=motif_pvalue]{motif_pvalue()}}.}
}
\value{
\code{list} Motif enrichment results as a length four list. Some list entries
may be \code{NULL} depending on function parameters.
\itemize{
\item \code{enrichment.report.hits}
\item \code{enrichment.report.pos}
\item \code{input.scan}
\item \code{bkg.scan}
}
}
\description{
Given a set of target and background sequences, test if the input motifs
are significantly enriched in the targets sequences relative to the
background sequences. See the "Sequence manipulation and scanning" vignette.
}
\details{
To find enriched motifs, \code{\link[=scan_sequences]{scan_sequences()}} is run on both
target and background sequences. If \code{search.mode = 'hits'},
\code{\link[stats:fisher.test]{stats::fisher.test()}} is run to test for enrichment. If
\code{search.mode = 'positional'}, then the test as set by
\code{positional.test} is run to check for positional differences
between target and background sequences. However if
\code{positional.test = 'shapiro.test'}, then only target sequence
hits are considered.

See \code{\link[=scan_sequences]{scan_sequences()}} for more info on scanning parameters.
}
\examples{
data(ArabidopsisPromoters)
data(ArabidopsisMotif)
enrich_motifs(ArabidopsisMotif, ArabidopsisPromoters, threshold = 0.01)

}
\references{
\insertRef{meme2}{universalmotif}
}
\seealso{
\code{\link[=scan_sequences]{scan_sequences()}}, \code{\link[=shuffle_sequences]{shuffle_sequences()}},
\code{\link[=add_multifreq]{add_multifreq()}}, \code{\link[=motif_pvalue]{motif_pvalue()}}
}
\author{
Benjamin Jean-Marie Tremblay \email{b2tremblay@uwaterloo.ca}
}
